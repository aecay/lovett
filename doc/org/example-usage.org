#+title: Example usage

#+property: header-args:python :session *lovett-docs* :results raw :wrap result

* Notes                                                            :noexport:

** TODO code block situation in this document

(and in these documents generally)

- ob-ipython
- correct virtualenv
- ...

* Introduction

The aim of this document is to walk through typical use cases of Lovett.
It assumes that you have successfully installed Lovett following the installation directions given elsewhere in this documentation.
*************** TODO link                                          :noexport:
*************** END

** What is Lovett for?

The extensional definition of Lovett is given elsewhere in the documentation.
*************** TODO link                                          :noexport:
*************** END
The aim of this section is rather to explain why Lovett exists, and what it will enable you to do.
Lovett transforms corpora into programmatic data structures.
This encourages you to think of parse trees not as static pieces of data, but as dynamic objects.
Unlike in botany, the extraction of data from these trees is not an exercise of slogging through the forest counting trunks and leaves.
All the counting is already contained in the parse itself (and someone already did a lot of slogging to make it available to you).
Extracting interesting data from a parsed corpus is much more like programming: creating instructions so that a computer will perform a task for you.

Existing infrastructure (primarily [[http://corpussearch.sourceforge.net/][CorpusSearch]]) does not fit this model of corpus research well.
CorpusSearch basically does one thing: search for a structure in the corpus.
It provides one very simple iteration operation: the coding query, which executes several searches sequentially.
It also provides one device for eliminating redundancy: definitions files, which can compress long search terms into shorter ones (but are limited to a single argument of one of CS’s search functions).
Finally, CS is difficult to interact with, since it requires a fair amount of boilerplate repetition, insists on accessing its inputs and outputs in particular locations in the file system, and is run from the system shell.
The cumulative effect of these aspects of CS is to obscure the relationship between corpus data and computer programming.

A fully fledged programming language, on the other hand, provides a variety of iteration constructs, and a variety of combinatory strategies for eliminating redundancy.
By embedding corpus data in such an environment, Lovett brings the following advantages:
- Ease of use.
  For users accustomed to programming, using Lovett should be easy to understand.
  Programming novices can avail themselves of the multitudinarious resources for learning programming (and python in particular).
  The skills they gain will thus be more transferable.
- Ease of understanding.
  Because programs written with Lovett can take advantage of appropriate programming constructs, they will be easier to understand.
  This means that linguists can share their corpus analyses more easily.
- Ease of integration.
  By picking python as the target language, Lovett can integrate with a wide variety of existing libraries for statistical analysis, text processing, data visualization, and other tasks.

*************** TODO say more in this list?                        :noexport:
*************** END

Corpus creation projects have made heavy use of CorpusSearch’s other feature – revision queries.
Lovett brings benefits to this use as well.
Even more than data extraction, transforming a corpus by means of rules is a programmatic task – indeed a kind of rule-based parsing.
Using a fully-developed programming language will allow the logic of this parsing to be expressed perspicuously – and indeed will aid in its development as well.


** Modes of Lovett usage

There are two ways to use Lovett.
The first is as a Python library like any other, which is imported at the top of a script file and used programmatically to execute a variety of operations.
This mode of usage will be useful for corpus revision and coding queries, and generally for advanced users with a very clear idea of what they wish to accomplish with Lovett.
*************** TODO link to doc sections re: revision and coding  :noexport:
*************** END
The second mode of usage combines with the Jupyter/IPython notebook.[fn:c8aca2ee]
*************** TODO link to website                               :noexport:
*************** END
The notebook is a type of “literate programming” that permits writing documents that intersperse prose text, source code, and the results of that code (automatically generated by running the code and inserting it into the document).
This allows code and documentation to be combined in a fluent way.
As an illustration, this documentation will be made available as an IPython notebook at (LINK; TODO).
*************** TODO get link working                              :noexport:
*************** END
This allows you to download this document and run its code on your own machine.

IPython also provides a system of rich display of results.
Rather than merely outputting text to a console, code run from IPython can return images, interactive HTML with Javascript, and other kinds of multimedia content.
This will be displayed in the document (usually itself loaded in a web browser).
Lovett takes advantage of this feature to provide formatted and sometimes interactive displays of corpus trees, sets of query results, etc.
There are many additional Python packages you can install which provide interactive graphs, tabular display of data frames (such as the result of coding queries), etc.
Lovett aims to integrate into this ecosystem.
Unless you are doing heavy lifting, using Lovett in the IPython notebook should be the best choice.
This mode of usage has been designated “iLovett,” and it must be enabled at the top of your notebook by entering the following code:
#+begin_src python :eval no
import lovett.ilovett

lovett.ilovett.initialize()
#+end_src

[fn:c8aca2ee] The former name of the project is “IPython,” and this name is still likely to be most familiar.
The language-independent parts have been split into the Jupyter project, with the Python-specific code retaining the IPython moniker.
As Lovett is a Python project, this documentation in general will use the IPython name.

* Loaders

The first task of an analyst is to load corpus data into Lovett.
Loaders are provided for this purpose in the =lovett.loaders= module for this purpose.
*************** TODO loaders (pl) or loader (sg)?                  :noexport:
*************** END
There are presently two kinds of loader:

- =FileLoader= :: This class implements loading from files on disk.  It will be the most commonly used loader
- =GithubLoader= :: This class implements loading corpus files from a repository hosted on github.
  It can be used to quickly disseminate code for an analysis of public data to a large group (for example students in a class) without requiring that they individually download the data.

The =loaders= module also provides loaders for the following publicly available corpora:

- [[http://www.linguist.is/icelandic_treebank/Icelandic_Parsed_Historical_Corpus_(IcePaHC)][IcePaHC]]

*************** TODO get permission for mbe text from Tony         :noexport:
*************** END

For this example, we’ll create a loader which targets a single file which hosted in the Lovett source code repository specifically to serve as an example.
This file is a parsed version of TODO.
(NB: You will need internet access in order to run the code in this section successfully.)
*************** TODO get this working                              :noexport:
*************** END


(Actually while I’m still getting this set up, I’ve used IcePaHC instead.)

#+begin_src python :exports code
import lovett.loader
my_loader = lovett.loader.GithubLoader(user="antonkarl",
                                       repo="icecorpus",
                                       directory="finished/")
#+end_src

#+RESULTS:

We can find out which files are contained in this corpus:

#+begin_src python :exports both :results raw :wrap result
my_loader.files()[0:5]
#+end_src

#+RESULTS:
#+BEGIN_result
['1150.firstgrammar.sci-lin.psd', '1150.homiliubok.rel-ser.psd', '1210.jartein.rel-sag.psd', '1210.thorlakur.rel-sag.psd', '1250.sturlunga.nar-sag.psd']
#+END_result

We can also get the contents of a file by name:[fn:1b3625ef]

#+begin_src python :exports both
my_loader.file("1150.firstgrammar.sci-lin.psd")[0:100]
#+end_src

#+RESULTS:
#+BEGIN_result

( (IP-MAT (PP (P Í-í)
	      (NP (QS-D flestum-margur) (NS-D löndum-land)))
	  (VBPI setja-setja)

#+END_result

# ) )

[fn:1b3625ef] Here we are displaying just the first 100 characters of the file, to avoid cluttering the document with a very long output.


The final functionality which a loader provides is to transform the files it accesses into a =Corpus= object.
By default, all available files will be included.
If you want a =Corpus= containing trees from just a single file, or set of files, you can pass a string or list to the =corpus= function.

*************** TODO use the ipython backend here to get nice html results :noexport:
*************** END

#+begin_src python
my_corpus = my_loader.corpus()
#+end_src

#+RESULTS:

Details about the file formats that Lovett understands will be presented elsewhere in the documentation.
*************** TODO link                                          :noexport:
*************** END

* Corpus objects
:PROPERTIES:
:ID:       23f4a84f-9ebc-4ef5-b101-7048edaf308a
:END:

A =Corpus= object serves as a container for a set of trees.
#+begin_src python
my_corpus
#+end_src
In iLovett, rather than the relatively simple display shown above, a corpus object displays an interactive viewer which allows you to page through the trees in the corpus one by one.
The following screenshot gives a glimpse of this functionality.

No screenshot yet! :-/
*************** TODO add screenshot, ideally a gif                 :noexport:
*************** END

A corpus object functions like a Python list, and you can access individual trees in the corpus just like elements of a list:
#+begin_src python
my_corpus[5]
#+end_src
Other features of Python lists all work: you can assign to elements of the list ~my_corpus[5] = <some tree object>~ , get the length ~len(my_corpus)~ , append trees ~my_corpus.append(<some tree object>)~, etc.
*************** TODO space-comma is lame, but needed for proper parsing :noexport:
*************** END

For a full list of such features, consult the Python documentation.
*************** TODO link                                          :noexport:
*************** END

In this documentation (TODO: not yet) and in iLovett, these results are formatted specially.
Under the hood, however, they are =Tree= objects (discussed below):
#+begin_src python
type(my_corpus[5])
#+end_src

Corpus objects have a variety of methods that are useful.  These include:
- ~to_db~ :: return an indexed corpus with the contents of this corpus
- ~write_penn_treebank~ , ~write_json~ :: write the contents of the corpus in either of two formats to a file
- ~matching_trees~ :: return the subset of trees in the corpus which match a query

An example of the latter method is given here:
#+begin_src python
import lovett.query as Q
my_results = my_corpus.matching_trees(Q.label("MD"))
my_results
#+end_src
The syntax of query expressions is covered elsewhere in this documentation.
*************** TODO link                                          :noexport:
*************** END
This simple query finds all sentences that have a modal verb (POS label =MD=) in our example corpus.

** Result sets

The result of ~matching_trees~ is a ~ResultSet~ object.
This mostly functions as a corpus object does, with the following differences:
1. A ResultSet is immutable, so you cannot add, delete, or change its contents
2. A ResultSet knows the query that generated it, and this information is displayed in the iLovett view, along with highlighting that indicates which nodes matched different parts of the query.  (TODO: illustrate with a screenshot)

*************** TODO screenshot                                    :noexport:
*************** END
*************** TODO idea for matching_trees on a ResultSet        :noexport:
Set the query of the resultant ResultSet to the and of the original query and the new one.
Maybe do this in an optional/configurable way?
Or otherwise make the result set know and display how it was generated
*************** END

* Tree objects

... etc etc

* Local variables                                                  :noexport:

#  LocalWords:  Lovett
